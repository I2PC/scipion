#!/usr/bin/env xmipp_python
#------------------------------------------------------------------------------------------------
# Protocol for Relion-based 3D classification
#
# Author: Roberto Marabini            roberto@cnb.csic.es    May 2013
#         J. M. de la Rosa Trevin     jmdelarosa@cnb.csic.es
#
#------------------------------------------------------------------------------------------------
# {begin_of_header}

# {eval} expandCommentRun()
# {cite}
CiteRelion3D = """
A Bayesian view on cryo-EM structure determination" 
by Sjors H.W. Scheres (DOI: 10.1016/j.jmb.2011.11.010)
"""

#------------------------------------------------------------------------------------------
# {section} Input
#------------------------------------------------------------------------------------------
# {hidden}{file}(images*.xmd){validate}(PathExists) Input images:
""" 
Provide a list of images from a stack <(Spider/MRC)> or metadata file that make up your data set.
The filenames should be relative to the <ProjectDir> where you are running the <Protocols>
If you have images outside the <ProjectDir> you should import them first.
Note that in the case of a stack, no metadata can be included and thus no CTF correction
can be performed.Nor will it be possible to perform noise spectra estimation or intensity
scale corrections in image groups.
"""
ImgMd = ""

# {file}(*optimiser.star){validate}(PathExists) continue from path:
"""Continue a relion classify protocol from this file """
inputFileName = ''


# {hidden}Continue from iteration:
""" 
Continue a relion classify protocol. Provide iteration number
"""
ContinueFromIteration = 1

#------------------------------------------------------------------------------------------------
# {section} Optimisation
#------------------------------------------------------------------------------------------------

# Number of iterations:
"""
Number of iterations to be performed. Note that the current implementation does NOT comprise a convergence criterium. Therefore, the calculations will need to be stopped by the user if further iterations do not yield improvements in resolution or classes.
"""
NumberOfIterations = 35

#-----------------------------------------------------------------------------
# {section} Sampling
#-----------------------------------------------------------------------------

# 
# {list_combo}(30,15,7.5,3.7,1.8,0.9,0.5,0.2,0.1) Angular sampling interval (deg):
"""There are only a few discrete angular samplings possible because we use the HealPix library to generate the sampling of the first two Euler angles on the sphere. The samplings are approximate numbers and vary slightly over the sphere.
"""
AngularSamplingDeg = '7.5'

# Offset search range (pix):
"""Probabilities will be calculated only for translations in a circle with this radius (in pixels). The center of this circle changes at every iteration and is placed at the optimal translation for each image in the previous iteration.
"""
OffsetSearchRangePix = 5

# Offset search step (pix):
"""Translations will be sampled with this step-size (in pixels).Translational sampling is also done using the adaptive approach. Therefore, if adaptive=1, the translations will first be evaluated on a 2x coarser grid.
"""
OffsetSearchStepPix = 1

# Perform local angular search? 
"""If set to Yes, then rather than performing exhaustive angular searches, local searches within the range given below will be performed. A prior Gaussian distribution centered at the optimal orientation in the previous iteration and with a stddev of 1/3 of the range given below will be enforced.
"""
PerformLocalAngularSearch = False

# {condition}(PerformLocalAngularSearch=='True')Local angular search range
"""
"""
LocalAngularSearchRange = 5.0

# {expert} Additional arguments
"""In this box command-line arguments may be provided that are not generated by the GUI. This may be useful for testing developmental options and/or expert use of the program. The command 'relion_refine' will print a list of possible options.
"""
AdditionalArguments = ""


# {eval} expandParallel()
#------------------------------------------------------------------------------------------------
# {section}{visualize} Results per Iteration and Ref3D
#------------------------------------------------------------------------------------------------
# {list_combo}( all, selection) Which class you want to visualize?
""" 
   All is equal to number of classes
   If you want two see  classes 2 and 5 
   choose selection and write
   2 5. In relion first reference is 1. 
"""
DisplayRef3DNo='all'

# {condition}(DisplayRef3DNo=='selection') Selected references 3D
""" Which reference do you want to visualize 
   All is equal to number of classes
   If you want two see  classes 2 and 5 
   choose selection and write
   2 5. In relion first reference is 1. 
"""
SelectedRef3DNo = ''

# {list_combo}(last, all, selection) Which iteration you want to visualize?
""" Which iteration do you want to visualize 
Set ot zero to see reference seed volumes
If you want two see iterations 2 and 5 
   choose selection and write
   2 5. In relion first iteration is 1. All is equal to all iterations from  1 to 
   number of iterations. Last is equal to number of iterations """
VisualizeIter = 'last'

# {condition}(VisualizeIter=='selection') Selected iterations
""" Which iteration do you want to visualize 
If you want two see iterations 2 and 5 write
   2 5. In relion first iteration is 0"""
SelectedIters = ''

# {list_combo}(x, y, z, surface) Display volumes 
""" x -> Visualize volumes in slices along x
    y -> Visualize volumes in slices along y
    z -> Visualize volumes in slices along z
    surface: surface rendering, you need chimera installed!
"""
DisplayVolumeSlicesAlong='z'

#------------------------------------------------------------------------------------------------
# {section}{visualize} Overall Results
#------------------------------------------------------------------------------------------------

# {view} Display reconstructed volume
""" Volume as given by the reconstruction algorithm
"""
DisplayReconstruction=False

# {view} Images Assigned to each Class
""" Images assigned to each class.
"""
DisplayImagesClassification=False



# {view} Display signal to noise ratio plots (SSNR)
DisplayResolutionPlotsSSNR=False

###############################
# {hidden}{view} Display resolution plots (FSC)
"""Not available for classify"""
DisplayResolutionPlotsFSC=False

# {hidden}{expert} Display a threshold in resolution plots (FSC)
ResolutionThreshold=0.5

# {view} Display angular distribution?
DisplayAngularDistribution=False

#  {list_combo} (2D, 3D) Display Angular distribution in
""" 2D option uses matplotlib while 3D uses chimera
"""
DisplayAngularDistributionWith='2D'

# {expert} Scale RedSpheres
""" when using chimera for displaying red angular
distribution set radius of maximum sphere"""
SpheresMaxradius=-1.

# {view} No. Images assigned to class
""" Images assigned to each class per iteration"""
TableImagesPerClass=False

# {view} Changes Offset, Ang, No Part
""" changes in orientation, offset. number images assigned to each class"""
TableChange=False

# {view} LikeliHood Per Image
""" Max likelihood per image may be used to delete images with smaller value. 
The higher, the better. Considere remove particles with low values"""
Likelihood=False

# {view} AveragePmax
""" Average (per class) of the maximum value of normalized probability function """
AvgPMAX=False
#------------------------------------------------------------------------------------------
# {end_of_header} USUALLY YOU DO NOT NEED TO MODIFY ANYTHING BELOW THIS LINE
#------------------------------------------------------------------------------------------------

from protocol_relion_classify_continue import *

if __name__ == '__main__':
    protocolMain(ProtRelionClassifierContinue)

